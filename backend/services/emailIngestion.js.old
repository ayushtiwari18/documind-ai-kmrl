import Imap from 'node-imap';
import { simpleParser } from 'mailparser';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class EmailIngestionService {
    constructor(config) {
        this.imap = new Imap({
            user: config.user,
            password: config.password,
            host: config.host,
            port: config.port,
            tls: config.tls,
            tlsOptions: { rejectUnauthorized: false }
        });

        this.setupEventHandlers();
    }

    setupEventHandlers() {
        this.imap.once('ready', () => this.onReady());
        this.imap.once('error', err => console.error('IMAP Error:', err));
        this.imap.once('end', () => console.log('IMAP Connection ended'));
    }

    async start() {
        return new Promise((resolve, reject) => {
            this.imap.once('ready', () => resolve());
            this.imap.once('error', reject);
            this.imap.connect();
        });
    }

    stop() {
        if (this.imap) {
            this.imap.end();
        }
    }

    onReady() {
        this.imap.openBox('INBOX', false, (err, box) => {
            if (err) {
                console.error('Error opening mailbox:', err);
                return;
            }

            this.setupMailListener();
        });
    }

    setupMailListener() {
        // Search for unread messages
        this.imap.search(['UNSEEN'], (err, results) => {
            if (err) {
                console.error('Error searching emails:', err);
                return;
            }

            if (!results || !results.length) {
                console.log('No new messages');
                return;
            }

            const f = this.imap.fetch(results, {
                bodies: '',
                markSeen: true
            });

            f.on('message', (msg, seqno) => this.processMessage(msg, seqno));
            f.once('error', err => console.error('Fetch error:', err));
            f.once('end', () => console.log('Fetched all messages'));
        });
    }

    async processMessage(msg, seqno) {
        let buffer = '';

        msg.on('body', stream => {
            stream.on('data', chunk => {
                buffer += chunk.toString('utf8');
            });

            stream.once('end', async () => {
                try {
                    const parsed = await simpleParser(buffer);
                    if (parsed.attachments && parsed.attachments.length > 0) {
                        this.processAttachments(parsed.attachments);
                    }
                } catch (err) {
                    console.error('Error parsing email:', err);
                }
            });
        });
    }

    processAttachments(attachments) {
        attachments.forEach(attachment => {
            const filename = crypto.createHash('md5').update(attachment.filename + Date.now()).digest('hex');
            const filepath = path.join(__dirname, '..', 'uploads', filename);

            fs.writeFile(filepath, attachment.content, err => {
                if (err) {
                    console.error('Error saving attachment:', err);
                    return;
                }
                console.log('Attachment saved:', filepath);
                // Here you would trigger any additional processing
                // Like updating database, triggering OCR, etc.
            });
        });
    }
}

export default EmailIngestionService;